# Java

## 객체지향언어
### 1.1 특징
- 재사용성, 유지보수, 중복된 코드의 제거, 
1. 코드의 재사용성이 높다. 
2. 코드의 관리가 용이하다. 
3. 신뢰성이 높은 프로그램이 가능하다.
+ 제어자와 메서드를 이용해 데이터를 보호하고, 올바는 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.


## 2.클래스와 객체

### 2.1 정의와 용도
- 클래스 : 객체를 정의해놓은 것, 객체를 생성하는 데 사용.
- 객체 : 실존하는 것, 가지고 있는 속성과 기능에 따라 용도가 정해짐.

클래스를 통해 객체를 만들면 매번 설계하지 않고 객체를 생성해서 사용할 수 있음.

### 2.2 객체와 인스턴스

- 인스턴스(instance) : 클래스로부터 만들어진 객체
- 인스턴스화(instantiate) : 클래스로부터 객체를 만드는 과정

### 2.3 객체의 구성요소 
- 속성(property) : 멤버변수(member variable), 특성(attribute), 필드(filed), 상태(state)
- 기능(funcfion) : 메서드(Method), 함수(function), 행위(behavior)

### 2.4 인스턴스의 생성과 사용
클래스 명 변수명;
변수명 = new 클래스명();
```
Tv t ; //참조변수 t선언
t = new Tv();  //new 연산자로 인스턴스 생성. 초기화.
```
- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.

### 2.5 객체 배열
객체를 배열로 다루는 것으로 객체의 주소가 저장됨.
참조변수들을 하나로 묶은 참조변수 배열.
같은 타입의 객체만 저장가능. 

```
Tv[] arr = new Tv[3]; // 참조변수 객체배열 생성
arr[0] = new Tv();
arr[1] = new Tv();
arr[2] = new Tv(); 
// 객체를 생성해서 배열의 각 요소에 저장 

for(int i=0; i<arr.length; i++){
    arr[i] = new Tv();
}
```
### 2.6 프로그래밍 관점에서 클래스

1. 클래스-데이터와 함수의 결합
- 프로그래밍 언어에서 데이터 처리를 위한 데이터 저장 형태 발전과정 : 변수->배열->구조체->클래스

+ 변수 : 하나의 데이터를 저장할 수 있는 공간
+ 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
+ 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
+ 클래스 : 데이터와 함수의 결합(구조체 +함수)

- 객체지향언어에서는 변수(데이터)와 함수를 하나의 클래스에 정의하여 관계가 깊은 변수와 함수들을 함께 다룰 수 있다.

2. 클래스-사용자정의 타입(User-defined type)
- 개발자가 서로 관련된 변수들을 묶어서 하나의 타입으로 추가하는 것


## 3.변수와 메서드 

### 3.1 선언 위치에 따른 변수의 종류
- 변수 : 클래스변수, 인스턴스변수, 지역변수
1. 인스턴스변수(instance variable) : 클래스 영역에 선언, 인스턴스 생성 시 생성, 독립적이 저장공간으로 각자 다른 값을 가질 수 있음. 
2. 클래스변수(class variable) : static+인스턴스 변수, 공동된 저장공간 공유.  
3. 지역변수(local variable) : 메서드 내에서 사용 가능. 블럭을 벗어나면 사용할 수 없음.

### 3.2 메서드
특정 작업을 수행하는 일련의 문장드을 하나로 묶은 것. 반드시 결과를 반환한다. 
메서드를 사용하는 이유는 높은 재사용성, 중복된 코드의 제거, 프로그램의 구조화가 있다.

### 3.3 메서드의 선언과 구현
메서드는 선언부와 구현부로 구분된다.
```
int add(int a, int b){ //선언부
    int result = a+b;  //구현부
    return result;
}
```
- 반환타입이 없는 경우 void
- 매개변수는 여러 개 선언 가능, return은 단 하나의 값만 반환 가능.

### 3.4 메서드의 호출

- 인자와 매개변수 
인자(argument) : 메서드를 호출할 떄 지정해준 값들. 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야한다. 타입이 일치하거나 형 변환도 가능해야한다.

### 3.5 return문

현재 실행한 메서드를 종료하고 호출한 메서드로 되돌아간다. 
모든 메서드는 적어도 하나의 return문이 필요하며, void인 경우, 컴파일러가 자동으로 return;를 자동적으로 추가한다.

### 3.6 기본형 매개변수와 참조형 매개변수 
매개변수 타입이 기본형(primitive type)이면 기본형의 값이, 참조형(reference)이면 인스턴스의 주소가 복사된다.
기본형으로 선언하면 저장된 값만 얻어오지만, 참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어오는 것은 물론 값을 변경하는 것도 가능하다.

### 3.7 참조형 반환타입
반환타입이 참조형이라는 것은 메서드가 '객체의 주소'를 반환하는 것을 의미한다.

### 3.8 재귀호출
메서드 내부에서 메서드 자신을 다시 호출하는 것을 말한다. 반복문보다 재귀호출의 수행시간이 더 오래걸리지만 사용하면 단순한 구조로 바뀔 수 있다. 
재귀호출의 대표적인 사례로는 '팩토리얼(factorial)'이 있다. 
한 숫자가 1이 될때까지 1씩 감소시켜가면서 계속해서 곱하는 것.
```
static int factorial(int n) {
    int result=0;
    if(n==1) {
        result=1;
    }else {
        result=n*factorial(n-1); // 재귀호출
    }
        return result;
}
```

### 3.9 클래스 메서드(static메서드)와 인스턴스 메서드
- 클래스 메서드 : 인스턴스와 관계없는 메서드. 객체를 생성하지 않고도 '클래스이름.메서드이름(매개변수)'로 호출가능. 
- 인스턴스 메서드 : 인스턴스 변수와 관련된 작업을 수행하는 메서드. 반드시 객체를 생성해야만 호출 할 수 있음.
1. 클래스 설계 시, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에  static을 붙인다. 
모든 인스턴스에 값이 유지되어야 하는 변수는 static를 붙여서 클래스로 변수로 정의.
2. 클래스변수는 인스턴스 생성여부와 관계없이 사용가능하다.
클래스가 메모리에 올라갈 때 자동으로 생성된다.
3. 클래스메서드는 인스턴스 변수를 사용할 수 없다.
인스턴스 멤버가 존재하는 시점에는 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수 있다.
인스턴스 멤버간 호출은 얼마든지 사용가능하다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면 static을 붙이는 것을 고려한다.
메서드의 작업요소 중에서 인스턴스 병수를 필요호 하지 않는 경우 static을 붙일 수 있다. 
메서드 호출시간이 짧아져 성능이 향상된다.

### 3.10 클래스멤버와 인스턴스 멤버간의 참조와 호출


## 4.오버로딩(overloading)
### 4.1 오버로딩이란?
- 한 클래스 내에 같은 이름의 메서드를 여러 개 정의 하는 것

### 4.2 오버로딩의 조건
1. 메서드 이름이 같아야한다.
2. 매개변수의 개수 또는 타입이 달라야한다.

- 대표적인 오버로딩의 예 : println 메서드

### 4.3 오버로딩의 장점
1. 여러 메서드를 하나의 이름으로 정의해 같은 기능을 하는 메서드를 구분할 수 있음.
2. 메서드의 이름를 절약할 수 있다. 

### 4.4 가변인자(variable argument)와 오버로딩
- 가변인자
JDk1.5부터 동적으로 지정하는 가변인자 사용 가능. 
'타입...변수명' 으로 선언.
가변인자는 내부적으로 배열을 이용하느 것으로 호출할 때마다 배열이 새롭게 생성.
가능한 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.

## 5. 생성자(Constructor)
### 5.1 생성자란?
인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'다. 메서드와 유사하지만 리터값이 없다.
생성자의 생성 조건은 1. 클래스와 이름이 같아야하고 2. 리턴값이 없다 는 것이다.

### 5.2 기본 생성자(default Constructor)
모든 클래스에는 반드시 하나의 생성자가 필요하다. 별도의 생성자가 없을 경우 컴파일러가 기본으로 기본생성자를 제공한다.

### 5.3 매개변수가 있는 생성자
다양한 생성자를 제공하면 인스턴스 생성 후에 별도로 초기화를 하지 않아도 된다.
```
Car c = new Car("white", "auto", 4);
```
### 5.4 생성자에서 다른 생성자 호출하기 - this(), this
this를 사용하면 생성자 간에 호출이 가능하다. 단, 반드시 첫 줄에서만 호출이 가능하다.
'this'는 참조변수로 인스턴스 자신을 가리킨다.

### 5.5 생성자를 이용한 인스턴스의 복사 

- 현재 사용하고 있는 인스턴스와 같은 상태를 갖는 인스턴스를 하나 더 만들고자 할 때 생성자를 이용할 수 있다. 
- 생성자를 사용하면 간결하고 직관적인 객체지향적 코드 작성이 가능하다.
    - 인스턴스 생성 시 결정해야하는 2가지 상황
        - 클래스 : 어떤 클래스의 인스턴스를 생성할 것인가?
        - 생성자 : 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

